name: Unity Code Quality & Auto-Format

on:
  push:
    branches: [ main ]
    paths:
      - 'Assets/Script/**/*.cs'
      - 'Assets/Script/**/*.asmdef'
      - '.editorconfig'
  pull_request:
    branches: [ main ]
    paths:
      - 'Assets/Script/**/*.cs'

permissions:
  contents: write      # コミットプッシュ用
  pull-requests: write # PR コメント用
  checks: write       # チェック結果の書き込み

jobs:
  code-quality:
    runs-on: ubuntu-latest
    
    steps:
    # 1. リポジトリのチェックアウト（トークン付き）
    - name: Checkout Repository
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    # 2. 変更されたファイルの検出（Assets/Script以下のみ）
    - name: Get Changed Files
      id: changed-files
      uses: tj-actions/changed-files@v35
      with:
        files: |
          Assets/Script/**/*.cs
        separator: ","
        
    # 3. .NET環境のセットアップ
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '6.0.x'
        
    # 4. dotnet-format ツールのインストール
    - name: Install dotnet-format
      run: |
        dotnet tool install -g dotnet-format
        echo "$HOME/.dotnet/tools" >> $GITHUB_PATH
        
    # 5. Unity用の複数プロジェクトファイル作成
    - name: Create Multiple Project Structure
      run: |
        echo "## 🔍 AssemblyDefinitionの検出" >> $GITHUB_STEP_SUMMARY
        
        # Assets/Script以下のAssemblyDefinitionファイルを検出
        ASMDEF_FILES=$(find Assets/Script -name "*.asmdef" 2>/dev/null || true)
        
        # プロジェクト情報を格納する配列
        declare -a PROJECT_NAMES
        declare -a PROJECT_GUIDS
        PROJECT_COUNT=0
        
        # ソリューションファイルの開始部分を作成
        cat > UnityProject.sln << EOF
        Microsoft Visual Studio Solution File, Format Version 12.00
        EOF
        
        # AssemblyDefinitionが見つかった場合の処理
        if [ -n "$ASMDEF_FILES" ]; then
          echo "発見されたAssemblyDefinition:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          for ASMDEF_FILE in $ASMDEF_FILES; do
            # AssemblyDefinitionのファイル名からプロジェクト名を取得
            ASMDEF_NAME=$(basename "$ASMDEF_FILE" .asmdef)
            PROJECT_DIR=$(dirname "$ASMDEF_FILE")
            
            echo "$ASMDEF_FILE -> $ASMDEF_NAME" >> $GITHUB_STEP_SUMMARY
            
            # プロジェクトGUIDを生成（ファイル名をベースにした一意ID）
            PROJECT_GUID=$(echo -n "$ASMDEF_NAME" | md5sum | cut -d' ' -f1)
            PROJECT_GUID="${PROJECT_GUID:0:8}-${PROJECT_GUID:8:4}-${PROJECT_GUID:12:4}-${PROJECT_GUID:16:4}-${PROJECT_GUID:20:12}"
            
            PROJECT_NAMES[$PROJECT_COUNT]="$ASMDEF_NAME"
            PROJECT_GUIDS[$PROJECT_COUNT]="$PROJECT_GUID"
            PROJECT_COUNT=$((PROJECT_COUNT + 1))
            
            # ソリューションファイルにプロジェクト追加
            cat >> UnityProject.sln << EOF
        Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "$ASMDEF_NAME", "$ASMDEF_NAME.csproj", "{$PROJECT_GUID}"
        EndProject
        EOF
            
            # 各AssemblyDefinitionに対応するcsprojファイルを作成
            cat > "$ASMDEF_NAME.csproj" << EOF
        <Project Sdk="Microsoft.NET.Sdk">
          <PropertyGroup>
            <TargetFramework>netstandard2.1</TargetFramework>
            <LangVersion>9.0</LangVersion>
            <Nullable>enable</Nullable>
            <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
            <AssemblyName>$ASMDEF_NAME</AssemblyName>
          </PropertyGroup>
          <ItemGroup>
            <Compile Include="$PROJECT_DIR/**/*.cs" />
            <PackageReference Include="Microsoft.Unity.Analyzers" Version="1.18.0" />
          </ItemGroup>
        </Project>
        EOF
            
          done
          
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "プロジェクト数: $PROJECT_COUNT" >> $GITHUB_STEP_SUMMARY
          
        else
          # AssemblyDefinitionが見つからない場合はデフォルトプロジェクトを作成
          echo "AssemblyDefinitionが見つからないため、デフォルトプロジェクトを作成" >> $GITHUB_STEP_SUMMARY
          
          cat >> UnityProject.sln << EOF
        Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Assembly-CSharp", "Assembly-CSharp.csproj", "{12345678-1234-1234-1234-123456789012}"
        EndProject
        EOF
          
          cat > Assembly-CSharp.csproj << EOF
        <Project Sdk="Microsoft.NET.Sdk">
          <PropertyGroup>
            <TargetFramework>netstandard2.1</TargetFramework>
            <LangVersion>9.0</LangVersion>
            <Nullable>enable</Nullable>
            <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
          </PropertyGroup>
          <ItemGroup>
            <Compile Include="Assets/Script/**/*.cs" />
            <PackageReference Include="Microsoft.Unity.Analyzers" Version="1.18.0" />
          </ItemGroup>
        </Project>
        EOF
        fi
        
        # ソリューションファイルの終了部分を追加
        cat >> UnityProject.sln << EOF
        Global
          GlobalSection(SolutionConfigurationPlatforms) = preSolution
            Debug|Any CPU = Debug|Any CPU
            Release|Any CPU = Release|Any CPU
          EndGlobalSection
        EndGlobal
        EOF
        
    # 6. コード分析の実行
    - name: Run Code Analysis
      id: analysis
      continue-on-error: true
      run: |
        echo "## 🔍 コード分析結果" >> $GITHUB_STEP_SUMMARY
        
        # ビルドと分析
        dotnet build --no-restore \
          --configuration Release \
          /p:TreatWarningsAsErrors=false \
          /p:EnforceCodeStyleInBuild=true \
          --verbosity minimal 2>&1 | tee analysis.log
        
        # 結果をサマリーに追加
        if [ $? -eq 0 ]; then
          echo "✅ コード分析: 成功" >> $GITHUB_STEP_SUMMARY
        else
          echo "⚠️ コード分析: 警告あり" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          grep -E "warning|error" analysis.log | head -20 >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
    # 7. コードクリーンアップの実行（Assets/Script以下のみ）
    - name: Auto-Format Project
      id: format
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        echo "## 🧹 コードクリーンアップ" >> $GITHUB_STEP_SUMMARY
        echo "対象ファイル数: ${{ steps.changed-files.outputs.all_changed_files_count }}" >> $GITHUB_STEP_SUMMARY
        echo "フォーマット対象: Assets/Script/**/*.cs" >> $GITHUB_STEP_SUMMARY
        
        # フォーマット前の状態を保存
        git diff --name-only > before_format.txt
        
        # Assets/Script以下のみを対象としたフォーマット実行
        echo "Assets/Script以下のファイルをフォーマット中..." >> $GITHUB_STEP_SUMMARY
        
        # 段階的にフォーマットを実行（Assets/Script以下のみ）
        echo "実行中: dotnet format whitespace --include Assets/Script/**/*.cs" >> $GITHUB_STEP_SUMMARY
        dotnet format whitespace --include "Assets/Script/**/*.cs" || true
        
        echo "実行中: dotnet format style --include Assets/Script/**/*.cs" >> $GITHUB_STEP_SUMMARY
        dotnet format style --severity info --include "Assets/Script/**/*.cs" || true
        
        echo "実行中: dotnet format analyzers --include Assets/Script/**/*.cs" >> $GITHUB_STEP_SUMMARY  
        dotnet format analyzers --severity info --include "Assets/Script/**/*.cs" || true
        
        # フォーマット後の変更を確認
        git diff --name-only > after_format.txt
        
        # Assets/Script以下で変更があったファイルのみをフィルタリング
        grep "^Assets/Script/" after_format.txt > script_changes.txt 2>/dev/null || touch script_changes.txt
        
        # 変更があったかチェック
        if [ -s script_changes.txt ]; then
          echo "formatted=true" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📝 フォーマットされたファイル:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat script_changes.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          # 対象外ファイルの変更を警告
          OTHER_CHANGES=$(grep -v "^Assets/Script/" after_format.txt 2>/dev/null || true)
          if [ -n "$OTHER_CHANGES" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "⚠️ **注意**: Assets/Script以外のファイルも変更されましたが、コミット対象外です:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$OTHER_CHANGES" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "formatted=false" >> $GITHUB_OUTPUT
          echo "✨ Assets/Script以下のファイルは既に適切にフォーマットされています" >> $GITHUB_STEP_SUMMARY
        fi
        
    # 8. 未使用のusingステートメントの削除（Assets/Script以下のみ）
    - name: Remove Unused Usings
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        echo "## 🗑️ 未使用コードの削除" >> $GITHUB_STEP_SUMMARY
        echo "対象: Assets/Script/**/*.cs" >> $GITHUB_STEP_SUMMARY
        
        # IDE0005: 未使用のusingディレクティブを削除（Assets/Script以下のみ）
        dotnet format analyzers --diagnostics IDE0005 --severity info --include "Assets/Script/**/*.cs" || true
        
        # その他のクリーンアップ（Assets/Script以下のみ）
        dotnet format analyzers --diagnostics IDE0001,IDE0002,IDE0004 --severity info --include "Assets/Script/**/*.cs" || true
        
    # 9. Unity特有のクリーンアップ（Assets/Script以下のみ）
    - name: Unity-Specific Cleanup
      if: steps.changed-files.outputs.any_changed == 'true'
      run: |
        echo "## 🔧 Unity特有のクリーンアップ" >> $GITHUB_STEP_SUMMARY
        echo "対象: Assets/Script以下のC#ファイル" >> $GITHUB_STEP_SUMMARY
        
        # カスタムスクリプトでUnity特有の修正
        cat > unity_cleanup.py << 'EOF'
        import re
        import sys
        import os
        
        def cleanup_unity_file(filepath):
            if not os.path.exists(filepath):
                print(f"ファイルが存在しません: {filepath}")
                return False
            
            # ファイルサイズチェック（大きすぎるファイルはスキップ）
            try:
                file_size = os.path.getsize(filepath)
                if file_size > 1024 * 1024:  # 1MB以上はスキップ
                    print(f"ファイルサイズが大きすぎます、スキップ: {filepath}")
                    return False
            except:
                return False
            
            try:
                # ファイル読み込み（複数エンコーディング対応）
                content = None
                for encoding in ['utf-8', 'shift_jis', 'cp932', 'utf-8-sig']:
                    try:
                        with open(filepath, 'r', encoding=encoding) as f:
                            content = f.read()
                        break
                    except UnicodeDecodeError:
                        continue
                    except Exception as e:
                        print(f"読み込みエラー ({encoding}): {filepath} - {e}")
                        continue
                
                if content is None:
                    print(f"エンコーディングの検出に失敗: {filepath}")
                    return False
                
                # バイナリファイルかチェック（ヌル文字が含まれている場合）
                if '\x00' in content:
                    print(f"バイナリファイルと判定、スキップ: {filepath}")
                    return False
                
                original = content
                
                # SerializeFieldの整形
                content = re.sub(
                    r'\[SerializeField\]\s*private\s+',
                    '[SerializeField] private ',
                    content
                )
                
                # 空のUnityメソッドにTODOコメントを追加
                content = re.sub(
                    r'(void\s+(?:Start|Awake|Update|FixedUpdate|LateUpdate)\s*\(\s*\)\s*{\s*})',
                    r'\1  // TODO: Implementation needed or remove this method',
                    content
                )
                
                # 変更があった場合のみ書き込み（UTF-8で保存）
                if content != original:
                    try:
                        with open(filepath, 'w', encoding='utf-8') as f:
                            f.write(content)
                        print(f"クリーンアップ完了: {filepath}")
                        return True
                    except Exception as e:
                        print(f"書き込みエラー: {filepath} - {e}")
                        return False
                
                return False
                
            except Exception as e:
                print(f"処理エラー: {filepath} - {e}")
                return False
        
        if __name__ == "__main__":
            success_count = 0
            error_count = 0
            
            for file in sys.argv[1:]:
                try:
                    if cleanup_unity_file(file):
                        success_count += 1
                except Exception as e:
                    print(f"予期しないエラー: {file} - {e}")
                    error_count += 1
            
            print(f"処理完了: 成功 {success_count}件, エラー {error_count}件")
        EOF
        
        # Assets/Script以下のC#ファイルのみに対してPythonスクリプトの実行
        SCRIPT_FILES=$(find Assets/Script -name "*.cs" 2>/dev/null || true)
        
        if [ -n "$SCRIPT_FILES" ]; then
          echo "処理対象ファイル:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$SCRIPT_FILES" | head -10 >> $GITHUB_STEP_SUMMARY
          [ $(echo "$SCRIPT_FILES" | wc -l) -gt 10 ] && echo "... (他 $(($(echo "$SCRIPT_FILES" | wc -l) - 10))個のファイル)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          # Pythonスクリプトの実行
          echo "$SCRIPT_FILES" | xargs python unity_cleanup.py
        else
          echo "Assets/Script以下にC#ファイルが見つかりませんでした" >> $GITHUB_STEP_SUMMARY
        fi
        
    # 10. 変更のコミット（pushの場合のみ、Assets/Script以下のみ）
    - name: Commit Formatted Code
      if: |
        github.event_name == 'push' && 
        steps.format.outputs.formatted == 'true' &&
        github.ref != 'refs/heads/main'
      run: |
        # Gitの設定
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Assets/Script以下の変更のみをステージング
        git add Assets/Script/
        
        # コミット対象があるかチェック
        if git diff --cached --quiet; then
          echo "コミット対象の変更がありません" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi
        
        # コミット
        CHANGED_FILES=$(git diff --cached --name-only | wc -l)
        git commit -m "🎨 Auto-format code [skip ci]" \
          -m "Formatted by GitHub Actions workflow" \
          -m "Files formatted in Assets/Script: $CHANGED_FILES"
        
        # プッシュ
        git push
        
    # 11. PRの場合の処理
    - name: Create Format Suggestions for PR
      if: |
        github.event_name == 'pull_request' && 
        steps.format.outputs.formatted == 'true'
      uses: reviewdog/action-suggester@v1
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        tool_name: dotnet-format
        fail_on_error: false
        
    # 12. 詳細レポートの生成
    - name: Generate Detailed Report
      if: always()
      run: |
        mkdir -p reports
        
        # フォーマットレポート
        if [ -f after_format.txt ]; then
          echo "# Code Formatting Report" > reports/format-report.md
          echo "## Changed Files" >> reports/format-report.md
          echo '```' >> reports/format-report.md
          cat after_format.txt >> reports/format-report.md
          echo '```' >> reports/format-report.md
          
          # 差分の詳細
          echo "## Detailed Changes" >> reports/format-report.md
          git diff --cached > reports/format-changes.diff
        fi
        
        # 分析レポート
        if [ -f analysis.log ]; then
          cp analysis.log reports/
        fi
        
    # 13. アーティファクトのアップロード
    - name: Upload Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: code-quality-reports
        path: reports/
        retention-days: 7
        
    # 14. PRステータスの更新
    - name: Update PR Status
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const formatted = '${{ steps.format.outputs.formatted }}' === 'true';
          const message = formatted 
            ? '🎨 コードが自動フォーマットされました。変更を確認してください。' 
            : '✅ コードは既に適切にフォーマットされています。';
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          });